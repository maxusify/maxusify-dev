---
import Icon from "astro-icon";

import Icon from "astro-icon";

import Navbar from "@/components/Navbar.astro";
import Base from "@/layouts/Base.astro";

import "@fontsource/righteous";
---

<Base>
  <main class="flex h-screen w-full flex-col justify-start items-center">
    <div class="fixed h-full w-full flex flex-col">
      <Navbar title="home" border={false} />
      <div class="h-full w-full flex flex-col justify-center items-center">
        <h1
          class="text-[10rem] text-slate-100 font-extrabold uppercase italic drop-shadow-2xl"
        >
          maxusify.dev
        </h1>
        <div class="p-5 flex flex-row gap-3 justify-center items-center">
          <a href="https://github.com/maxusify">
            <button
              class="flex items-center gap-2 bg-slate-100 p-3 rounded-2xl text-black"
            >
              <Icon name="mdi:github" /><span class="text-xl font-bold"
                >GitHub Profile</span
              >
            </button>
          </a>
          <a href="https://www.linkedin.com/in/michalpedzik/">
            <button
              class="flex items-center gap-2 bg-sky-600 p-3 rounded-2xl text-slate-100"
            >
              <Icon name="mdi:linkedin" /><span class="text-xl font-bold"
                >LinkedIn Profile</span
              >
            </button>
          </a>
          <a href="https://medium.com/@maxusify">
            <button
              class="flex items-center gap-2 bg-gray-800 p-3 rounded-2xl text-slate-100"
            >
              <Icon name="mdi:medium" /><span class="text-xl font-bold"
                >Medium Profile</span
              >
            </button>
          </a>
        </div>
      </div>
    </div>
    <script>
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";

      // import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      let group;
      let container, stats;
      const particlesData = [];
      let camera, scene, renderer;
      let positions, colors;
      let particles;
      let pointCloud;
      let particlePositions;
      let linesMesh;

      const maxParticleCount = 1000;
      let particleCount = 250;
      const r = 800;
      const rHalf = r / 2;

      const effectController = {
        showDots: true,
        showLines: true,
        minDistance: 150,
        limitConnections: true,
        maxConnections: 5,
        particleCount: 50,
      };

      init();
      animate();

      function initGUI() {
        const gui = new GUI();

        gui.add(effectController, "showDots").onChange(function (value) {
          pointCloud.visible = value;
        });
        gui.add(effectController, "showLines").onChange(function (value) {
          linesMesh.visible = value;
        });
        gui.add(effectController, "minDistance", 10, 300);
        gui.add(effectController, "limitConnections");
        gui.add(effectController, "maxConnections", 0, 30, 1);
        gui
          .add(effectController, "particleCount", 0, maxParticleCount, 1)
          .onChange(function (value) {
            particleCount = parseInt(value);
            particles.setDrawRange(0, particleCount);
          });
      }

      function init() {
        // initGUI();

        container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          1,
          4000
        );
        camera.position.z = 750;

        // const controls = new OrbitControls(camera, container);
        // controls.minDistance = 1000;
        // controls.maxDistance = 3000;

        scene = new THREE.Scene();

        group = new THREE.Group();
        scene.add(group);

        const helper = new THREE.BoxHelper(
          new THREE.Mesh(new THREE.BoxGeometry(r, r, r))
        );
        helper.material.color.setHex(0x101010);
        helper.material.blending = THREE.AdditiveBlending;
        helper.material.transparent = true;
        group.add(helper);

        const segments = maxParticleCount * maxParticleCount;

        positions = new Float32Array(segments * 3);
        colors = new Float32Array(segments * 3);

        const pMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 3,
          blending: THREE.AdditiveBlending,
          transparent: true,
          sizeAttenuation: false,
        });

        particles = new THREE.BufferGeometry();
        particlePositions = new Float32Array(maxParticleCount * 3);

        for (let i = 0; i < maxParticleCount; i++) {
          const x = Math.random() * r - r / 2;
          const y = Math.random() * r - r / 2;
          const z = Math.random() * r - r / 2;

          particlePositions[i * 3] = x;
          particlePositions[i * 3 + 1] = y;
          particlePositions[i * 3 + 2] = z;

          // add it to the geometry
          particlesData.push({
            velocity: new THREE.Vector3(
              -1 + Math.random() * 2,
              -1 + Math.random() * 2,
              -1 + Math.random() * 2
            ),
            numConnections: 0,
          });
        }

        particles.setDrawRange(0, particleCount);
        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(particlePositions, 3).setUsage(
            THREE.DynamicDrawUsage
          )
        );

        // create the particle system
        pointCloud = new THREE.Points(particles, pMaterial);
        group.add(pointCloud);

        const geometry = new THREE.BufferGeometry();

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3).setUsage(
            THREE.DynamicDrawUsage
          )
        );
        geometry.setAttribute(
          "color",
          new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage)
        );
        geometry.computeBoundingSphere();
        geometry.setDrawRange(0, 0);

        const material = new THREE.LineBasicMaterial({
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          transparent: true,
        });

        linesMesh = new THREE.LineSegments(geometry, material);
        group.add(linesMesh);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;

        container.appendChild(renderer.domElement);
        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        let vertexpos = 0;
        let colorpos = 0;
        let numConnected = 0;

        for (let i = 0; i < particleCount; i++)
          particlesData[i].numConnections = 0;

        for (let i = 0; i < particleCount; i++) {
          // get the particle
          const particleData = particlesData[i];

          particlePositions[i * 3] += particleData.velocity.x;
          particlePositions[i * 3 + 1] += particleData.velocity.y;
          particlePositions[i * 3 + 2] += particleData.velocity.z;

          if (
            particlePositions[i * 3 + 1] < -rHalf ||
            particlePositions[i * 3 + 1] > rHalf
          )
            particleData.velocity.y = -particleData.velocity.y;

          if (
            particlePositions[i * 3] < -rHalf ||
            particlePositions[i * 3] > rHalf
          )
            particleData.velocity.x = -particleData.velocity.x;

          if (
            particlePositions[i * 3 + 2] < -rHalf ||
            particlePositions[i * 3 + 2] > rHalf
          )
            particleData.velocity.z = -particleData.velocity.z;

          if (
            effectController.limitConnections &&
            particleData.numConnections >= effectController.maxConnections
          )
            continue;

          // Check collision
          for (let j = i + 1; j < particleCount; j++) {
            const particleDataB = particlesData[j];
            if (
              effectController.limitConnections &&
              particleDataB.numConnections >= effectController.maxConnections
            )
              continue;

            const dx = particlePositions[i * 3] - particlePositions[j * 3];
            const dy =
              particlePositions[i * 3 + 1] - particlePositions[j * 3 + 1];
            const dz =
              particlePositions[i * 3 + 2] - particlePositions[j * 3 + 2];
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (dist < effectController.minDistance) {
              particleData.numConnections++;
              particleDataB.numConnections++;

              const alpha = 1.0 - dist / effectController.minDistance;

              positions[vertexpos++] = particlePositions[i * 3];
              positions[vertexpos++] = particlePositions[i * 3 + 1];
              positions[vertexpos++] = particlePositions[i * 3 + 2];

              positions[vertexpos++] = particlePositions[j * 3];
              positions[vertexpos++] = particlePositions[j * 3 + 1];
              positions[vertexpos++] = particlePositions[j * 3 + 2];

              colors[colorpos++] = alpha;
              colors[colorpos++] = alpha;
              colors[colorpos++] = alpha;

              colors[colorpos++] = alpha;
              colors[colorpos++] = alpha;
              colors[colorpos++] = alpha;

              numConnected++;
            }
          }
        }

        linesMesh.geometry.setDrawRange(0, numConnected * 2);
        linesMesh.geometry.attributes.position.needsUpdate = true;
        linesMesh.geometry.attributes.color.needsUpdate = true;

        pointCloud.geometry.attributes.position.needsUpdate = true;

        requestAnimationFrame(animate);

        render();
      }
    </div>
    <script>
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";

      // import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      let group;
      let container, stats;
      const particlesData = [];
      let camera, scene, renderer;
      let positions, colors;
      let particles;
      let pointCloud;
      let particlePositions;
      let linesMesh;

      const maxParticleCount = 1000;
      let particleCount = 250;
      const r = 800;
      const rHalf = r / 2;

      const effectController = {
        showDots: true,
        showLines: true,
        minDistance: 150,
        limitConnections: true,
        maxConnections: 5,
        particleCount: 50,
      };

      init();
      animate();

      function initGUI() {
        const gui = new GUI();

        gui.add(effectController, "showDots").onChange(function (value) {
          pointCloud.visible = value;
        });
        gui.add(effectController, "showLines").onChange(function (value) {
          linesMesh.visible = value;
        });
        gui.add(effectController, "minDistance", 10, 300);
        gui.add(effectController, "limitConnections");
        gui.add(effectController, "maxConnections", 0, 30, 1);
        gui
          .add(effectController, "particleCount", 0, maxParticleCount, 1)
          .onChange(function (value) {
            particleCount = parseInt(value);
            particles.setDrawRange(0, particleCount);
          });
      }

      function init() {
        // initGUI();

        container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          1,
          4000
        );
        camera.position.z = 750;

        // const controls = new OrbitControls(camera, container);
        // controls.minDistance = 1000;
        // controls.maxDistance = 3000;

        scene = new THREE.Scene();

        group = new THREE.Group();
        scene.add(group);

        const helper = new THREE.BoxHelper(
          new THREE.Mesh(new THREE.BoxGeometry(r, r, r))
        );
        helper.material.color.setHex(0x101010);
        helper.material.blending = THREE.AdditiveBlending;
        helper.material.transparent = true;
        group.add(helper);

        const segments = maxParticleCount * maxParticleCount;

        positions = new Float32Array(segments * 3);
        colors = new Float32Array(segments * 3);

        const pMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 3,
          blending: THREE.AdditiveBlending,
          transparent: true,
          sizeAttenuation: false,
        });

        particles = new THREE.BufferGeometry();
        particlePositions = new Float32Array(maxParticleCount * 3);

        for (let i = 0; i < maxParticleCount; i++) {
          const x = Math.random() * r - r / 2;
          const y = Math.random() * r - r / 2;
          const z = Math.random() * r - r / 2;

          particlePositions[i * 3] = x;
          particlePositions[i * 3 + 1] = y;
          particlePositions[i * 3 + 2] = z;

          // add it to the geometry
          particlesData.push({
            velocity: new THREE.Vector3(
              -1 + Math.random() * 2,
              -1 + Math.random() * 2,
              -1 + Math.random() * 2
            ),
            numConnections: 0,
          });
        }

        particles.setDrawRange(0, particleCount);
        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(particlePositions, 3).setUsage(
            THREE.DynamicDrawUsage
          )
        );

        // create the particle system
        pointCloud = new THREE.Points(particles, pMaterial);
        group.add(pointCloud);

        const geometry = new THREE.BufferGeometry();

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3).setUsage(
            THREE.DynamicDrawUsage
          )
        );
        geometry.setAttribute(
          "color",
          new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage)
        );
        geometry.computeBoundingSphere();
        geometry.setDrawRange(0, 0);

        const material = new THREE.LineBasicMaterial({
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          transparent: true,
        });

        linesMesh = new THREE.LineSegments(geometry, material);
        group.add(linesMesh);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;

        container.appendChild(renderer.domElement);
        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        let vertexpos = 0;
        let colorpos = 0;
        let numConnected = 0;

        for (let i = 0; i < particleCount; i++)
          particlesData[i].numConnections = 0;

        for (let i = 0; i < particleCount; i++) {
          // get the particle
          const particleData = particlesData[i];

          particlePositions[i * 3] += particleData.velocity.x;
          particlePositions[i * 3 + 1] += particleData.velocity.y;
          particlePositions[i * 3 + 2] += particleData.velocity.z;

          if (
            particlePositions[i * 3 + 1] < -rHalf ||
            particlePositions[i * 3 + 1] > rHalf
          )
            particleData.velocity.y = -particleData.velocity.y;

          if (
            particlePositions[i * 3] < -rHalf ||
            particlePositions[i * 3] > rHalf
          )
            particleData.velocity.x = -particleData.velocity.x;

          if (
            particlePositions[i * 3 + 2] < -rHalf ||
            particlePositions[i * 3 + 2] > rHalf
          )
            particleData.velocity.z = -particleData.velocity.z;

          if (
            effectController.limitConnections &&
            particleData.numConnections >= effectController.maxConnections
          )
            continue;

          // Check collision
          for (let j = i + 1; j < particleCount; j++) {
            const particleDataB = particlesData[j];
            if (
              effectController.limitConnections &&
              particleDataB.numConnections >= effectController.maxConnections
            )
              continue;

            const dx = particlePositions[i * 3] - particlePositions[j * 3];
            const dy =
              particlePositions[i * 3 + 1] - particlePositions[j * 3 + 1];
            const dz =
              particlePositions[i * 3 + 2] - particlePositions[j * 3 + 2];
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (dist < effectController.minDistance) {
              particleData.numConnections++;
              particleDataB.numConnections++;

              const alpha = 1.0 - dist / effectController.minDistance;

              positions[vertexpos++] = particlePositions[i * 3];
              positions[vertexpos++] = particlePositions[i * 3 + 1];
              positions[vertexpos++] = particlePositions[i * 3 + 2];

              positions[vertexpos++] = particlePositions[j * 3];
              positions[vertexpos++] = particlePositions[j * 3 + 1];
              positions[vertexpos++] = particlePositions[j * 3 + 2];

              colors[colorpos++] = alpha;
              colors[colorpos++] = alpha;
              colors[colorpos++] = alpha;

              colors[colorpos++] = alpha;
              colors[colorpos++] = alpha;
              colors[colorpos++] = alpha;

              numConnected++;
            }
          }
        }

        linesMesh.geometry.setDrawRange(0, numConnected * 2);
        linesMesh.geometry.attributes.position.needsUpdate = true;
        linesMesh.geometry.attributes.color.needsUpdate = true;

        pointCloud.geometry.attributes.position.needsUpdate = true;

        requestAnimationFrame(animate);

        render();
      }

      function render() {
        renderer.setClearColor(0xffffff, 0);
        const time = Date.now() * 0.001;
        group.rotation.y = time * 0.1;
        renderer.render(scene, camera);
      }
    </script>
    <div id="container" class="h-full w-full bg-transparent"></div>
  </main>
</Base>
      function render() {
        renderer.setClearColor(0xffffff, 0);
        const time = Date.now() * 0.001;
        group.rotation.y = time * 0.1;
        renderer.render(scene, camera);
      }
    </script>
    <div id="container" class="h-full w-full bg-transparent"></div>
  </main>
</Base>

<style>
  [astro-icon] {
    width: auto;
    height: 2rem;
  }

  h1 {
    font-family: "Righteous";
  }

  h1 {
    font-family: "Righteous";
  }
</style>
